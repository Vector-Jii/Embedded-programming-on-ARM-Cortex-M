/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include <stdio.h>
#include "main.h"

void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);
void init_task_stack(void);

void init_systick_timer(uint32_t tick_hz);
void init_scheduler_stack(uint32_t sched_top_stack);
void enable_proessor_fault(void);
void switch_sp_to_psp(void);
uint32_t get_psp_value(void);

//Stack pointer for each task
uint32_t psp_of_tasks[MAX_TASK] = {T1_STACK_START,T2_STACK_START,T3_STACK_START,T4_STACK_START};

uint32_t task_handlers [MAX_TASK];   //Stores address of each task function

uint8_t current_task = 0;

int main(void)
{
	enable_proessor_fault();
	init_scheduler_stack(SCHEDULER_STACK_START);

	task_handlers[0] = (uint32_t)task1_handler;  //capture the address of the task handlers
	task_handlers[1] = (uint32_t)task2_handler;  // Store task address
	task_handlers[2] = (uint32_t)task3_handler;
	task_handlers[3] = (uint32_t)task4_handler;


	init_task_stack();

	init_systick_timer(TICK_HZ);

	switch_sp_to_psp();

	task1_handler();



    /* Loop forever */
	for(;;);
}

void task1_handler(void)
{
	while(1)
	{
		printf("Inside task 1 \n");
	}
}

void task2_handler(void)
{
	while(1)
	{
		printf("Inside task 2 \n");
	}
}

void task3_handler(void)
{
	while(1)
	{
		printf("Inside task 3 \n");
	}
}

void task4_handler(void)
{
	while(1)
	{

		printf("Inside task 4 \n");
	}
}

__attribute__((naked))void init_scheduler_stack(uint32_t sched_top_stack)
{
	__asm volatile("MSR MSP,%0": :"r"(sched_top_stack) : );
	__asm volatile("BX LR ");
}

void init_systick_timer(uint32_t tick_hz)
{
	uint32_t *pSYST_RVR = (uint32_t*)0xE000E014;
	//calculate count value []
	uint32_t count_value = (SYSTICK_TIMER_CLK/tick_hz)-1;

	//Clear the value of SVR
	*pSYST_RVR &= ~(0x00FFFFFF);

	//load the value in SVR
	*pSYST_RVR |= count_value;

	// do some settings
	uint32_t *pSYST_CSR = (uint32_t*) 0xE000E010;

	//processor clock src
	*pSYST_CSR |= (1 << 1);

	//Enable sys_tick exception request
	*pSYST_CSR |= (1 << 2);

	//Enable sys tick
	*pSYST_CSR |= (1 << 0);


}

void init_task_stack(void)
{
	uint32_t *pPSP;

	for(int j=0;j<MAX_TASK;j++)
	{
		pPSP = (uint32_t*)psp_of_tasks[j];

		pPSP--;
		*pPSP = DUMMY_XPSR; // 0x01000000

		pPSP--;//PC
		*pPSP = task_handlers[j];

		pPSP--;//LR
		*pPSP = 0xFFFFFFFD;

		for(int k = 0;k<13;k++)
		{
			pPSP--;
			*pPSP = 0;
		}

		psp_of_tasks[j] = (uint32_t)pPSP;
	}
}

void enable_proessor_fault(void)
{
	//1. Enable all the configurable exception like usage,bus and mem manage fault

		uint32_t *pSHCSR = (uint32_t*)0xE000ED24;    // pointer to the SHCSR
		*pSHCSR |= (1<< 16); // memory manage
		*pSHCSR |= (1<< 17); // bus
		*pSHCSR |= (1<< 18); // usage
}

__attribute__((naked))void switch_sp_to_psp(void)
{
	//1. Initialize the PSP to the TASK1  stack start

	//get value of psp of current task
	__asm volatile ("PUSH {LR}");  //preserve LR that connects back to main
	__asm volatile ("BL get_psp_value");
	__asm volatile ("MSR PSP,R0"); //Initialize PSP
	__asm volatile ("POP {LR}");//POPS back LR value

	//2. Change sp to PSP using the CONTROL register

	__asm volatile ("MOV R0,0x02");
	__asm volatile ("MSR CONTROL,R0");
	__asm volatile ("BX LR");

}

uint32_t get_psp_value(void)
{
	return psp_of_tasks[current_task];
}

void save_psp_value(uint32_t current_psp_value)
{
	psp_of_tasks[current_task] = current_psp_value;
}

void update_next_task()
{
	current_task++;
	current_task = current_task % MAX_TASK;
}

__attribute__((naked))void SysTick_Handler(void)
{
	//Save the context of the current task

		//1. Get the current running task's PSP value
		__asm volatile("MRS R0,PSP");

		//2. Using that PSP value store SP2 (R4- R11)
		__asm volatile("STmDB R0!,{R4-R11}");

		__asm volatile("PUSH {LR}");

		//3. save the current value of PSP
		__asm volatile("BL save_psp_value");

	// Retrive the context of next task

		//1. Decide next task to run
		__asm volatile("BL update_next_task");

		//2. get its past PSP value
		__asm volatile ("BL get_psp_value");

		//3. Using that PSP value retrive SP2(R4 TO R11)
		__asm volatile ("LDMIA R0!, {R4-R11}");

		//4. update and exit
		__asm volatile ("MSR PSP,R0");

		__asm volatile("POP {LR}");

		__asm volatile("BX LR");


}

//2. Implement the fault handlers

void HardFault_Handler(void)
{
	printf("Inside hard fault handler ");
	while(1);
}

void MemManage_Handler(void)
{
	printf("memory manage fault handler");
	while(1);
}

void BusFault_Handler(void)
{
	printf("Inside bus fault handler");
	while(1);
}





